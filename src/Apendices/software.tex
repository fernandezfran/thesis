\chapter{Software desarrollado}

En la última década, Python se ha convertido en un lenguaje de programación 
importante dentro de la comunidad científica debido a su facilidad de uso y 
versatilidad en la manipulación y visualización de datos ~\cite{millman2011}. 
Por lo tanto, los software diseñados en esta tesis han sido escritos en este
lenguaje y construidos sobre las librerías usuales del cómputo científico como
NumPy \cite{numpy}, SciPy \cite{scipy}, pandas \cite{pandas}, 
matplotlib \cite{matplotlib} y scikit-learn \cite{sklearn1, sklearn2}. 


\section{Control de calidad de software}

El control de calidad del software hace referencia al conjunto de reglas y 
procedimientos que deben utilizarse para verificar que el software cumple 
determinados estándares de calidad subjetivos. Un procedimiento habitual son las 
pruebas unitarias (\textit{unit testing} en inglés), que consisten en aislar una 
función del código y comprobar que funciona como se espera \cite{jazayeri2007}. 
Otro procedimiento habitual se define a partir de este y es el 
\textit{code-coverage}, que determina que proporción del software se ha testeado
\cite{miller1963}. El estilo y la legibilidad del código también es importante
y aquí se ha seguido la guía de estilo PEP8 de Python, la misma se asegura con 
la herramienta flake8. Además, los mismos fueron desarrollados utilizando control 
de versiones git y distribuidos bajo la Licencia MIT, fomentando su uso tanto en 
entornos académicos como comerciales. Todo esto se realizó buscando que el 
software sea fácil de mantener y que respete los estándares de la comunidad Python.


\section{galpynostatic}\label{software:galpynostatic}

Este paquete denominado \path{galpynostatic} fue escrito para la utilización
del modelo heurístico presentado en el capítulo \ref{ch:un}. El mismo distribuye 
los datos de los diagramas galvanostáticos, un módulo de preprocesamiento de datos
para obtener capacidades de descarga a un potencial de corte dado a partir de 
medidas de perfiles galvanostáticos y una clase que realiza la regresión sobre la 
superficie y permite diferentes tipos de gráficos y estimaciones de parámetros.

A continuación se muestra un ejemplo de uso:

\lstinputlisting[language=Python]{apendices/ejemplo_galpynostatic.py}

A \path{galpynostatic} se le realizan múltiples pruebas unitarias sobre datos de
de electrodos actuales y de materiales de investigación de próxima generación en 
baterías de litio, el \textit{coverage} del mismo alcanza el 100\% del software
en su versión inicial.

Por último, el código fuente está disponible en un repositorio público 
(\url{https://github.com/fernandezfran/galpynostatic}) y todos los nuevos cambios 
confirmados en este repositorio se prueban automáticamente con el servicio de 
integración continua de GitHub Actions. También se genera una documentación a 
partir de los docstrings del código, junto con una guía de instalación,
tutoriales y ejemplos con aplicaciones reales, que se hacen públicos en el 
servicio read-the-docs (\url{https://galpynostatic.readthedocs.io/en/latest/}). 
Además, \path{galpynostatic} está disponible para su instalación en el Python 
Package-Index (\url{https://pypi.org/project/galpynostatic/}).

%
%\section{galpynostatic.metric}
%
%TODO
%
%
%\section{macchiato}
%
%TODO
%
%Ejemplo de cálculo del corrimiento químico de la estructura cristalina 
%Li$_{13}$Si$_{4}$ mediante el uso del modelo a primeros vecinos introducido en 
%el capítulo TODO:
%\lstinputlisting[language=Python]{apendices/ejemplo_macchiato.py}
%
%
%\section{Otros códigos}
%
%\subsection{sierras}
%Con \path{sierras} se automatiza el proceso de ajustar la ecuación de Arrhenius 
%(\ref{eq:arrhenius}) en procesos difusivos y la obtención de información a partir 
%de la misma. Este código también se encuentra público 
%(\url{https://github.com/fernandezfran/sierras}) y cada vez que se realiza un 
%cambio se llevan a cabos tests unitarios sobre distintos datos extraídos de 
%literatura. Un ejemplo simple de como se utiliza se presenta a continuación:
%
%\lstinputlisting[language=Python]{apendices/ejemplo_sierras.py}
%
%La versión inicial de este código fue presentada como trabajo final en la materia
%\href{https://github.com/leliel12/diseno_sci_sfw}{\tt Diseño de software para 
%cómputo científico.}
%
%\subsection{exma}
%Para analizar trayectorias de dinámica molecular, dentro de la comunidad de Python
%se encuentra la librería \path{MDAnalysis} \cite{mdanalysis1, mdanalysis2}. Sin
%embargo, no todos los observables descriptos en la sección \ref{s:observables}
%han sido implementados, por ejemplo, no se puede calcular directamente el número
%de coordinación. Para ello se escribió \path{exma}
%(\url{https://github.com/fernandezfran/exma}), que además de contar con esta
%implementación presenta distintas facilidades para computar observables 
%electroquímicos presentados en distintos capítulos de esta tesis. Algunas partes
%de este software han sido escritas en \path{C}, para tener mayor velocidad de 
%cálculo, y tienen una interfaz en Python para ser utilizadas.
%
%\subsection{aelm}
%Para el método de exploración acelerada de mínimos locales, introducido en 
%la sección \ref{s:aelm} del capítulo \ref{ch:caracterizacion}, se escribió un 
%módulo de Python, \path{aelm} (\url{https://github.com/fernandezfran/aelm}), que 
%toma una trayectoria de una dinámica molecular sesgada, minimiza cada uno de los 
%frames con algún programa de dinámica molecular a elección (\path{LAMMPS} o 
%\path{GEMS}, por ejemplo) y guarda las configuraciones atómicas y las energías 
%para su posterior análisis, como se realizó en el capítulo 
%\ref{ch:caracterizacion} ¿o TODO?
%
%\subsection{cluster-connections}
%Se escribió un código en \path{C++}, 
%\url{https://github.com/fernandezfran/cluster-connections}, con un algoritmo de
%\textit{clustering} para deconvolucionar numéricamente el segundo pico de la RDF
%según la cantidad de vecinos que interconectan a segundos vecinos, como se analizó
%en la sección \ref{s:interconexion} del capítulo \ref{ch:caracterizacion}, 
%en la figura \ref{fig:interconexiones}.
